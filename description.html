<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>このゲームエンジンについての説明</title>
</head>
<body>
<h1>この作品についての説明</h1>

<h2>この作品の概要</h2>
<div>
これの作品は、Scala.jsで作成した、自作の物理エンジンを搭載した、自作ゲームエンジンフレームワークです。
プログラミングを用いた複雑なモデルの実装の実践や、微積分、線形代数、物理学、3Dグラフィクスの理解を深めるために
外部ライブラリには依存せず、行列処理などの数値処理をすべて自前で実装し、また3DグラフィックのレンダリングはすべてWebGLのAPIに直接アクセスして行なっています。

ソースコードは<a href="https://github.com/Ogiwara-CostlierRain464/scalajs-webgl">ここ</a>で公開しています
</div>

<h2>この作品を作った理由</h2>
<div>
  <ul>
    <li>既存のゲームエンジンアーキテクチャであるEntity Component Systemに不満があったため。</li>
    <li>複雑なモデルの良い題材だと思ったから。自分はソフトウェア工学に興味があり、その学問の目的は「如何にして複雑なモデルをソースコードに落とし込むか」である。数あるいくつものモデルのうち物理学は特に複雑なもので、これを扱うことは非常に良い勉強になると考えたから</li>
    <li>多くの数値処理系のライブラリに不満があったから。十分なアサーションや、型検証をできているものが少ないので、Ada等の方法を参考にした。</li>
    <li>物理シュミレータではなく、物理エンジンを選択した理由は、リアルタイム処理のためのよりよいアルゴリズムの選択等が重要になるから</li>
    <li>Scala自体の練習のため</li>
    <li>サークル活動の一環として、自作のゲームエンジンでゲームを作成し、展示したかったから</li>
  </ul>

</div>
<h2>アーキテクチャの説明</h2>

<div>
  ゲームエンジンの作成は、誇張して言えば新たな宇宙を創造することであるとも言えます。

  <h3>レイヤー分割</h3>
  <img src="./image/layer.jpeg" height="200">
  <div>
    矢印が A -> B は「AがBに依存する」ことを表します。また、systemの部分にある*は、「複数のsystemがworldに依存する」ことを表します。
    各レイヤーについて説明します。
    <ul>
      <li>math: ベクトル、行列、四元数の演算などの数学的な知識を保有します。具体的なエンティティーは存在しない、法則のみが存在する虚無宇宙であると言えます。</li>
      <li>world: 世界と、その世界に属するエンティティーの知識を保有します。また、利便性のためにエンティティーの位置、姿勢、形状などの単純な物理系の知識も持ちます。</li>
      <li>render: 世界を外側から俯瞰するカメラや、それを二次元スクリーンに投影する知識を保有します。</li>
      <li>system: 各系の知識を保有します。系とは、宇宙の一部のうち、考察の対象として注目している部分を表します。
        具体的なものとしては、物理系、オブジェクトの親子関係を定義する系、その他独自のゲームロジックを記述する系があります。
        世界に属するエンティティーを実体モデルとして解釈したのに対し、系は世界の動きに対する私たちの解釈、すなわち論理モデルであると言えます。
        当然、すべての生物の動作、感情は原子の動きをシュミレートすることによって再現することができますが、それはあまりにも多くの計算を要することになります。
        そこで、私たちはある時には数学を、ある時には自然言語を用いて解釈付けをし、論理モデルとして落ち着かせてきました。このように、モデルの定義は世界に対するトップダウン的な捉え方なので、パーソナルエリア<s>やATフィールド</s>といった精神的なものも系にできます。</li>
      <li>app: アプリケーション、つまりこのゲームエンジンを応用して作る作品を表します。</li>
    </ul>

  </div>

  <h3>データの流れ</h3>
  <img src="./image/flow.jpeg" height="200">
  <div>
    worldには、それに属するentityが存在します。各系を通してworldの状態を更新していき、world'が生成されます。world'からその時点での世界のスナップショットを作成し、
    それをScreenに渡します。これを繰り返すことによって、世界が動き出し、それがスクリーンに描画され続けます。
  </div>
  <img src="./image/s1.jpeg" height="100">
  <div>
    各系同士は、直交する系同士は並列処理ができます。また関連性のある系同士は親子関係を持たせることにより、整合性を確保できます。このため、物理系も系の一部として一般化することによって、
    簡単に扱うことができるようになっています。
  </div>
  <img src="./image/s2.jpeg" height="100">
  <div>
    worldの情報の更新を適用する際、系同士がworldの同じ情報を変更する場合は、その変更処理を同期する必要がありますが、
    そうでない場合はフレームを跨いだ並列処理が可能となります。
  </div>
</div>




<h2>物理系の説明</h2>
物理系の実装は、NormalPhysicsSystemクラスで確認できます。物理系は、以下五つのパイプラインから構築されます

<ul>
  <li>外力を加える、ForcePipeline</li>
  <li>ブロードフェーズ衝突判定を行う、BroadPhasePipeline</li>
  <li>ナローフェーズ衝突判定を行う、DetectCollisionPipeline</li>
  <li>拘束条件を解決する、ConstraintSolverPipeline</li>
  <li>上記パイプラインの計算結果を元に、オブジェクトの位置・姿勢を更新するIntegratePipeline</li>
</ul>



<h2>今後のロードマップ</h2>


<ul>

</ul>
</body>
</html>